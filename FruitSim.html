<!DOCTYPE html>

<html>
<head>
<title>FruitSim</title>

<link rel="stylesheet" type="text/css" href="css/styles.css" />

<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/stats.js"></script>
<script type="text/javascript" src="js/physi.js"></script>

<script type="text/javascript">
    'use strict';

    Physijs.scripts.worker = 'js/physijs_worker.js';
    Physijs.scripts.ammo = 'ammo.js';

    var initScene;
    var initEngine;
    var initLights;
    var initObjects;
    var initEventHandling;
    var render;
    var spawnFruit;
    var createTower;
    var model_loader;
    var texture_loader;
    var renderer;
    var render_stats;
    var physics_stats;
    var scene;
    var dir_light;
    var am_light;
    var camera;
    var table;
    var blocks = [];
    var table_material;
    var block_material;
    var intersect_plane;
    var selected_block = null;
    var mouse_position = new THREE.Vector3;
    var block_offset = new THREE.Vector3;
    var _i;
    var _v3 = new THREE.Vector3;
		var fruits = [];
    var melon_material;
    var melon;

    var modelDirectory = "models/"; // Folder containing model files, relative to this HTML file

    var modelFileNames = [
        "watermelon.json"
    ];

    var modelRotations = [ // rotations to be applied to models
    [0,0,0]
    ];

    initEngine = function() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );

        render_stats = new Stats();
        render_stats.domElement.style.position = 'absolute';
        render_stats.domElement.style.top = '1px';
        render_stats.domElement.style.zIndex = 100;
        document.getElementById( 'viewport' ).appendChild( render_stats.domElement );

        physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );

        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
        scene.addEventListener(
            'update',
            function() {

                if ( selected_block !== null ) {

                    _v3.copy( mouse_position ).add( block_offset ).sub( selected_block.position ).multiplyScalar( 5 );
                    _v3.y = 0;
                    selected_block.setLinearVelocity( _v3 );

                    // Reactivate all of the blocks
                    _v3.set( 0, 0, 0 );
                    for ( _i = 0; _i < blocks.length; _i++ ) {
                        blocks[_i].applyCentralImpulse( _v3 );
                    }
                }

                scene.simulate( undefined, 1 );
                physics_stats.update();
            }
        );

        camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );
        camera.position.set( 0, 30, 70 );
        camera.lookAt(new THREE.Vector3( 0, 0, 0 ));
        scene.add( camera );
    };

    initLights = function() {
        // ambient light
        am_light = new THREE.AmbientLight( 0x444444 );
        scene.add( am_light );

        // directional light
        dir_light = new THREE.DirectionalLight( 0xFFFFFF );
        dir_light.position.set( 20, 30, -5 );
        dir_light.target.position.copy( scene.position );
        dir_light.castShadow = true;
        dir_light.shadowCameraLeft = -30;
        dir_light.shadowCameraTop = -30;
        dir_light.shadowCameraRight = 30;
        dir_light.shadowCameraBottom = 30;
        dir_light.shadowCameraNear = 20;
        dir_light.shadowCameraFar = 200;
        dir_light.shadowBias = -.001
        dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
        dir_light.shadowDarkness = .5;
        scene.add( dir_light );
    };

    initObjects = function() {
        // Loaders
        // model_loader = new THREE.JSONLoader();
        texture_loader = new THREE.TextureLoader();
        
        // Materials
        table_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/wood.jpg' )}),
            .9, // high friction
            .2 // low restitution
        );
        table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
        table_material.map.repeat.set( 5, 5 );

        block_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/plywood.jpg' )}),
            .4, // medium friction
            .4 // medium restitution
        );
        block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
        block_material.map.repeat.set( 1, .5 );

        melon_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/melon.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        melon_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
        melon_material.map.repeat.set( 1, .5 );
    };

    initScene = function() {
        initEngine();
        initLights();
        initObjects();

        // Table
        table = new Physijs.BoxMesh(
            new THREE.BoxGeometry(50, 1, 50),
            table_material,
            0, // mass
            { restitution: .2, friction: .8 }
        );
        table.position.y = -.5;
        table.receiveShadow = true;
        scene.add(table);

        spawnFruit(); //spawns a fruit object in the center of the table
        createTower(); //creates the jenga tower from the physi.js example

        intersect_plane = new THREE.Mesh(
            new THREE.PlaneGeometry( 150, 150 ),
            new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })
        );
        intersect_plane.rotation.x = Math.PI / -2;
        scene.add( intersect_plane );

        initEventHandling();

        requestAnimationFrame( render );
        scene.simulate();
    };

    render = function() {
        requestAnimationFrame( render );
        renderer.render( scene, camera );
        render_stats.update();
    };

    spawnFruit = (function() {
        console.log("spawnFruit function called"); //test
        model_loader = new THREE.JSONLoader();
        model_loader.load("models/watermelon.json",
        function(geometry, materials){
              melon = new Physijs.BoxMesh( //was ConvexMesh, changed to BoxMesh to get object collision (need to find a way to make box bigger)
                geometry,
                melon_material,
                5,
                { retitution: 0.2, friction: 0.8 }
              );
							melon.scale.set(5,5,5);
							melon.position.set(10,5,0); //was 3,3,0
              scene.add(melon);
		});
    });

    createTower = (function() {
        var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
            block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
        return function() {
            var i, j, rows = 16,
                block;
            for ( i = 0; i < rows; i++ ) {
                for ( j = 0; j < 3; j++ ) {
                    block = new Physijs.BoxMesh( block_geometry, block_material );
                    block.position.y = (block_height / 2) + block_height * i;
                    if ( i % 2 === 0 ) {
                        block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
                        block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    } else {
                        block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    }
                    block.receiveShadow = true;
                    block.castShadow = true;
                    scene.add( block );
                    blocks.push( block );
                }
            }
        }
    })();

    initEventHandling = (function() {
        var _vector = new THREE.Vector3,
            handleMouseDown, handleMouseMove, handleMouseUp;

        handleMouseDown = function( evt ) {
            var ray, intersections;
			_vector.set(
                ( evt.clientX / window.innerWidth ) * 2 - 1,
                -( evt.clientY / window.innerHeight ) * 2 + 1,
                1
            );
            _vector.unproject( camera );
            ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
            intersections = ray.intersectObjects( blocks );

            if ( intersections.length > 0 ) {
                selected_block = intersections[0].object;

                _vector.set( 0, 0, 0 );
                selected_block.setAngularFactor( _vector );
                selected_block.setAngularVelocity( _vector );
                selected_block.setLinearFactor( _vector );
                selected_block.setLinearVelocity( _vector );

                mouse_position.copy( intersections[0].point );
                block_offset.subVectors( selected_block.position, mouse_position );

                intersect_plane.position.y = mouse_position.y;
            }
        };

        handleMouseMove = function( evt ) {
            var ray, intersection,
                i, scalar;

            if ( selected_block !== null ) {
                _vector.set(
                    ( evt.clientX / window.innerWidth ) * 2 - 1,
                    -( evt.clientY / window.innerHeight ) * 2 + 1,
                    1
                );
                _vector.unproject( camera );
                ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
                intersection = ray.intersectObject( intersect_plane );
                mouse_position.copy( intersection[0].point );
            }
        };

        handleMouseUp = function( evt ) {
            if ( selected_block !== null ) {
                _vector.set( 1, 1, 1 );
                selected_block.setAngularFactor( _vector );
                selected_block.setLinearFactor( _vector );
				selected_block = null;
            }
        };
        return function() {
            renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
            renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
            renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
        };
    })();

window.onload = initScene;
</script>
</head>

<body>
    <div id="heading">
        <h1>FruitSim</h1>
        <p>A Work in Progress...</p>
    </div>
    <div id="viewport"></div>
</body>

</html>
