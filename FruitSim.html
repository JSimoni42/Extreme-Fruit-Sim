<!DOCTYPE html>

<html>
<head>
<title>FruitSim</title>

<link rel="stylesheet" type="text/css" href="css/styles.css" />

<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/stats.js"></script>
<script type="text/javascript" src="js/physi.js"></script>

<script type="text/javascript">
    'use strict';

    Physijs.scripts.worker = 'js/physijs_worker.js';
    Physijs.scripts.ammo = 'ammo.js';

    var initScene;
    var initEngine;
    var initLights;
    var initObjects;
    var initEventHandling;
    
    var render;
    
    var spawnFruit;
    var createTower;

    var model_loader;
    var texture_loader;
    var renderer;

    var render_stats;
    var physics_stats;

    var scene;
    var lights = {};
    var camera;

    var table;
    var blocks = [];
    var table2;
    var melon;
    var bulb;
    var hammer;
    

    var table_material;
    var block_material;
    var melon_material;
    var bulb_material;
    var hammer_material;

    var intersect_plane;
    var selected_block = null;
    var mouse_position = new THREE.Vector3;
    var block_offset = new THREE.Vector3;
    
    var _i;
    var _v3 = new THREE.Vector3;

    var modelDirectory = "models/"; // Folder containing model files, relative to this HTML file

    var modelFileNames = [
        "watermelon.json"
    ];

    var modelRotations = [ // rotations to be applied to models
    [0,0,0]
    ];

    initEngine = function() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );

        render_stats = new Stats();
        render_stats.domElement.style.position = 'absolute';
        render_stats.domElement.style.top = '1px';
        render_stats.domElement.style.zIndex = 100;
        document.getElementById( 'viewport' ).appendChild( render_stats.domElement );

        physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );

        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
        scene.addEventListener(
            'update',
            function() {

                if ( selected_block !== null ) {

                    _v3.copy( mouse_position ).add( block_offset ).sub( selected_block.position ).multiplyScalar( 5 );
                    _v3.y = 0;
                    selected_block.setLinearVelocity( _v3 );

                    // Reactivate all of the blocks
                    _v3.set( 0, 0, 0 );
                    for ( _i = 0; _i < blocks.length; _i++ ) {
                        blocks[_i].applyCentralImpulse( _v3 );
                    }
                }

                scene.simulate( undefined, 1 );
                physics_stats.update();
            }
        );

        camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );
        camera.position.set( 0, 30, 70 );
        camera.lookAt(new THREE.Vector3( 0, 0, 0 ));
        scene.add( camera );
    };

    initLights = function() {
        // ambient light
        lights.am_light = new THREE.AmbientLight( 0x444444 );
        scene.add(lights.am_light);

        // directional light
        lights.dir_light = new THREE.DirectionalLight( 0xFFFFFF );
        lights.dir_light.position.set( 20, 30, -5 );
        lights.dir_light.target.position.copy( scene.position );
        lights.dir_light.castShadow = true;
        lights.dir_light.shadowCameraLeft = -30;
        lights.dir_light.shadowCameraTop = -30;
        lights.dir_light.shadowCameraRight = 30;
        lights.dir_light.shadowCameraBottom = 30;
        lights.dir_light.shadowCameraNear = 20;
        lights.dir_light.shadowCameraFar = 200;
        lights.dir_light.shadowBias = -.001
        lights.dir_light.shadowMapWidth = lights.dir_light.shadowMapHeight = 2048;
        lights.dir_light.shadowDarkness = .5;
        scene.add(lights.dir_light);
    };

    initObjects = function() {
        // Loaders
        texture_loader = new THREE.TextureLoader();
        model_loader = new THREE.JSONLoader();
        
        // Materials
        table_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/wood.jpg' )}),
            .9, // high friction
            .2 // low restitution
        );
        table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
        table_material.map.repeat.set( 5, 5 );

        block_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/plywood.jpg' )}),
            .4, // medium friction
            .4 // medium restitution
        );
        block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
        block_material.map.repeat.set( 1, .5 );

        melon_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/melon.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        melon_material.map.wrapS = melon_material.map.wrapT = THREE.RepeatWrapping;
        melon_material.map.repeat.set( 1, .5 );
        
        bulb_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/melon.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        bulb_material.map.wrapS = bulb_material.map.wrapT = THREE.RepeatWrapping;
        bulb_material.map.repeat.set( 1, .5 );
        
        hammer_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/melon.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        hammer_material.map.wrapS = hammer_material.map.wrapT = THREE.RepeatWrapping;
        hammer_material.map.repeat.set( 1, .5 );
    };

    initScene = function() {
        initEngine();
        initLights();
        initObjects();

        // Table
        table = new Physijs.BoxMesh(
            new THREE.BoxGeometry(50, 1, 50),
            table_material,
            0, // mass
            { restitution: .2, friction: .8 }
        );
        table.position.y = -.5;
        table.receiveShadow = true;
        scene.add(table);

/*         model_loader.load("models/table.json",
        function(geometry, materials){
            table2 = new Physijs.ConvexMesh(
                geometry,
                table_material,
                0, //mass
                {retitution: 0.2, friction: 0.8}
            );
            table2.scale.set(11,11,11);
            table2.position.set(0,-25,0);
            table2.castShadow = true;
            table2.receiveShadow = true;
            scene.add(table2);
		});         */
        
        model_loader.load("models/lightbulb.json",
        function(geometry, materials){
            bulb = new Physijs.ConvexMesh(
                geometry,
                bulb_material,
                5, //mass
                {retitution: 0.2, friction: 0.8}
            );
            bulb.scale.set(2,2,2);
            bulb.position.set(-10,0,0);
            bulb.castShadow = true;
            scene.add(bulb);
		});
        
        model_loader.load("models/hammer.json",
        function(geometry, materials){
            hammer = new Physijs.ConvexMesh(
                geometry,
                hammer_material,
                5, //mass
                {retitution: 0.2, friction: 0.8}
            );
            hammer.scale.set(8,8,8);
            hammer.position.set(-10,0,10);
            hammer.rotation.set(0,-90,0);
            hammer.castShadow = true;
            hammer.receiveShadow = true;            
            scene.add(hammer);
		});
        
        spawnFruit(); //spawns a fruit object in the center of the table
        createTower(); //creates the jenga tower from the physi.js example

        intersect_plane = new THREE.Mesh(
            new THREE.PlaneGeometry( 150, 150 ),
            new THREE.MeshBasicMaterial({opacity: 0, transparent: true})
        );
        intersect_plane.rotation.x = Math.PI / -2;
        scene.add(intersect_plane);

        initEventHandling();

        requestAnimationFrame(render);
        scene.simulate();
    };

    render = function() {
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
    };

    spawnFruit = (function() {        
        model_loader.load("models/watermelon.json",
        function(geometry, materials){
            melon = new Physijs.ConvexMesh(
                geometry,
                melon_material,
                5,
                {retitution: 0.2, friction: 0.8}
            );
            
            melon.scale.set(5,5,5);
            melon.position.set(10,0,0);
            melon.castShadow = true;
            melon.receiveShadow = true;
            scene.add(melon);
		});
    });

    createTower = (function() {
        var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
            block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
        return function() {
            var i, j, rows = 16,
                block;
            for ( i = 0; i < rows; i++ ) {
                for ( j = 0; j < 3; j++ ) {
                    block = new Physijs.BoxMesh( block_geometry, block_material );
                    block.position.y = (block_height / 2) + block_height * i;
                    if ( i % 2 === 0 ) {
                        block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
                        block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    } else {
                        block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    }
                    block.receiveShadow = true;
                    block.castShadow = true;
                    scene.add( block );
                    blocks.push( block );
                }
            }
        }
    })();

    initEventHandling = (function() {
        var _vector = new THREE.Vector3,
            handleMouseDown, handleMouseMove, handleMouseUp;

        handleMouseDown = function( evt ) {
            var ray, intersections;
			_vector.set(
                ( evt.clientX / window.innerWidth ) * 2 - 1,
                -( evt.clientY / window.innerHeight ) * 2 + 1,
                1
            );
            _vector.unproject( camera );
            ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
            intersections = ray.intersectObjects( blocks );

            if (intersections.length > 0) {
                selected_block = intersections[0].object;

                _vector.set(0, 0, 0);
                selected_block.setAngularFactor(_vector);
                selected_block.setAngularVelocity(_vector);
                selected_block.setLinearFactor(_vector);
                selected_block.setLinearVelocity(_vector);

                mouse_position.copy( intersections[0].point );
                block_offset.subVectors( selected_block.position, mouse_position );

                intersect_plane.position.y = mouse_position.y;
            }
        };

        handleMouseMove = function(evt) {
            var ray, intersection,
                i, scalar;

            if (selected_block !== null) {
                _vector.set(
                    (evt.clientX / window.innerWidth) * 2 - 1,
                    -(evt.clientY / window.innerHeight) * 2 + 1,
                    1
                );
                _vector.unproject(camera);
                ray = new THREE.Raycaster(camera.position, _vector.sub(camera.position).normalize());
                intersection = ray.intersectObject(intersect_plane);
                mouse_position.copy(intersection[0].point);
            }
        };

        handleMouseUp = function( evt ) {
            if ( selected_block !== null ) {
                _vector.set( 1, 1, 1 );
                selected_block.setAngularFactor( _vector );
                selected_block.setLinearFactor( _vector );
				selected_block = null;
            }
        };
        return function() {
            renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
            renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
            renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
        };
    })();

window.onload = initScene;
</script>
</head>

<body>
    <div id="heading">
        <h1>FruitSim</h1>
        <p>A Work in Progress...</p>
    </div>
    <div id="viewport"></div>
</body>

</html>
