<!DOCTYPE html>

<html>
<head>
<title>FruitSim</title>
	
<link rel="stylesheet" type="text/css" href="css/styles.css" />
	
<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/stats.js"></script>
<script type="text/javascript" src="js/physi.js"></script>
	
<script type="text/javascript">	
	'use strict';
	
	Physijs.scripts.worker = 'js/physijs_worker.js';
	Physijs.scripts.ammo = 'ammo.js';
	
	var initScene;
	var initEngine;
	var initLights;
	var initObjects;
	var initEventHandling;
	var render;
	var spawnFruit;
	var createTower;
	var model_loader;
	var texture_loader;
	var renderer;
	var render_stats;
	var physics_stats;
	var scene;
	var dir_light;
	var am_light;
	var camera;
	var table;
	var blocks = [];
	var table_material;
	var block_material;
	var intersect_plane;
	var selected_block = null;
	var mouse_position = new THREE.Vector3;
	var block_offset = new THREE.Vector3;
	var _i;
	var _v3 = new THREE.Vector3;
	
    var modelDirectory = "models/"; // Folder containing model files, relative to this HTML file

	var modelFileNames = [
		"watermelon.json"
    ];

	var modelRotations = [ // rotations to be applied to models
    [0,0,0]
    ];
    
	initEngine = function() {
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.shadowMapSoft = true;
		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
		
		render_stats = new Stats();
		render_stats.domElement.style.position = 'absolute';
		render_stats.domElement.style.top = '1px';
		render_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( render_stats.domElement );

		physics_stats = new Stats();
		physics_stats.domElement.style.position = 'absolute';
		physics_stats.domElement.style.top = '50px';
		physics_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );
		
		scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
		scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
		scene.addEventListener(
			'update',
			function() {

				if ( selected_block !== null ) {
					
					_v3.copy( mouse_position ).add( block_offset ).sub( selected_block.position ).multiplyScalar( 5 );
					_v3.y = 0;
					selected_block.setLinearVelocity( _v3 );
					
					// Reactivate all of the blocks
					_v3.set( 0, 0, 0 );
					for ( _i = 0; _i < blocks.length; _i++ ) {
						blocks[_i].applyCentralImpulse( _v3 );
					}
				}

				scene.simulate( undefined, 1 );
				physics_stats.update();
			}
		);
		
		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			1000
		);
		camera.position.set( 0, 30, 70 );
		camera.lookAt(new THREE.Vector3( 0, 0, 0 ));
		scene.add( camera );
	};
	
	initLights = function() {
		// ambient light
		am_light = new THREE.AmbientLight( 0x444444 );
		scene.add( am_light );

		// directional light
		dir_light = new THREE.DirectionalLight( 0xFFFFFF );
		dir_light.position.set( 20, 30, -5 );
		dir_light.target.position.copy( scene.position );
		dir_light.castShadow = true;
		dir_light.shadowCameraLeft = -30;
		dir_light.shadowCameraTop = -30;
		dir_light.shadowCameraRight = 30;
		dir_light.shadowCameraBottom = 30;
		dir_light.shadowCameraNear = 20;
		dir_light.shadowCameraFar = 200;
		dir_light.shadowBias = -.001
		dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
		dir_light.shadowDarkness = .5;
		scene.add( dir_light );
	};
	
	initObjects = function() {
		// Loaders
        model_loader = new THREE.JSONLoader();
		texture_loader = new THREE.TextureLoader();
		
        //model importing
        try {
            console.log(modelDirectory + modelFileNames[0]); //printing to console 
            loader.load(modelDirectory + modelFileNames[0], modelLoaded(geometry, modelRotations[0]));
        }
        catch (e) {
            console.log("Failed to load model");
        }
	
		// Materials
		table_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/wood.jpg' )}),
			.9, // high friction
			.2 // low restitution
		);
		table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
		table_material.map.repeat.set( 5, 5 );
		
		block_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/plywood.jpg' )}),
			.4, // medium friction
			.4 // medium restitution
		);
		block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
		block_material.map.repeat.set( 1, .5 );
	};
	
	initScene = function() {
		initEngine();
        initLights();
		initObjects();
		
		// Table
		table = new Physijs.BoxMesh(
			new THREE.BoxGeometry(50, 1, 50),
			table_material,
			0, // mass
			{ restitution: .2, friction: .8 }
		);
		table.position.y = -.5;
		table.receiveShadow = true;
		scene.add(table);
		
		//spawnFruit(); //spawns a fruit object in the center of the table
        createTower(); //creates the jenga tower from the physi.js example
		
		intersect_plane = new THREE.Mesh(
			new THREE.PlaneGeometry( 150, 150 ),
			new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })
		);
		intersect_plane.rotation.x = Math.PI / -2;
		scene.add( intersect_plane );

		initEventHandling();
		
		requestAnimationFrame( render );
		scene.simulate();
	};
	
	render = function() {
		requestAnimationFrame( render );
		renderer.render( scene, camera );
		render_stats.update();
	};
    
/**
 * This function will be called when the JSONLoader has
 * finished loading a model.  This function creates a three.js
 * Mesh object to hold the model.  It translates the object so that
 * its center is at the origin.  It wraps the object in another object
 * that is used to scale and rotate the object.  The scale is set
 * so that the maximum coordinate in its vertices, in absolute
 * value, is scaled to 10.  The rotation is set to the second parameter,
 * which is used to set up an appropriate orientation for viewing
 * the model.  A plain white Lambert material is used for the model;
 * the material from the model file is ignored.
 */ 
    function modelLoaded(geometry, rotation) {

        /* create the object from the geometry was loaded, with a white material. */
           
        var object = new THREE.Mesh(geometry,
                            new THREE.MeshLambertMaterial( {color:"white"} ));

        /* Determine the ranges of x, y, and z in the vertices of the geometry. */

        var xmin = Infinity;
        var xmax = -Infinity;
        var ymin = Infinity;
        var ymax = -Infinity;
        var zmin = Infinity;
        var zmax = -Infinity;
        for (var i = 0; i < geometry.vertices.length; i++) {
            var v = geometry.vertices[i];
            if (v.x < xmin)
                xmin = v.x;
            else if (v.x > xmax)
                xmax = v.x;
            if (v.y < ymin)
                ymin = v.y;
            else if (v.y > ymax)
                ymax = v.y;
            if (v.z < zmin)
                zmin = v.z;
            else if (v.z > zmax)
                zmax = v.z;
        }
        
        /* translate the center of the object to the origin */
        var centerX = (xmin+xmax)/2;
        var centerY = (ymin+ymax)/2; 
        var centerZ = (zmin+zmax)/2;
        var max = Math.max(centerX - xmin, xmax - centerX);
        max = Math.max(max, Math.max(centerY - ymin, ymax - centerY) );
        max = Math.max(max, Math.max(centerZ - zmin, zmax - centerZ) );
        var scale = 10/max;
        object.position.set( -centerX, -centerY, -centerZ );
        if (window.console) {
           console.log("Loading finished, scaling object by " + scale);
           console.log("Center at ( " + centerX + ", " + centerY + ", " + centerZ + " )");
        }
        
        /* Create the wrapper, model, to scale and rotate the object. */
        
        model = new THREE.Object3D();
        model.add(object);
        model.scale.set(scale,scale,scale);
        model.rotation.set(rotation[0],rotation[1],rotation[2]);
        scene.add(model);
        render();
    }
    spawnFruit = (function() {
        console.log("spawnFruit function called"); //test
    });
    
	createTower = (function() {
		var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
			block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
		
		return function() {
			var i, j, rows = 16,
				block;
			
			for ( i = 0; i < rows; i++ ) {
				for ( j = 0; j < 3; j++ ) {
					block = new Physijs.BoxMesh( block_geometry, block_material );
					block.position.y = (block_height / 2) + block_height * i;
					if ( i % 2 === 0 ) {
						block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
						block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					} else {
						block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					}
					block.receiveShadow = true;
					block.castShadow = true;
					scene.add( block );
					blocks.push( block );
				}
			}
		}
	})();
	
	initEventHandling = (function() {
		var _vector = new THREE.Vector3,
			handleMouseDown, handleMouseMove, handleMouseUp;
		
		handleMouseDown = function( evt ) {
			var ray, intersections;
			
			_vector.set(
				( evt.clientX / window.innerWidth ) * 2 - 1,
				-( evt.clientY / window.innerHeight ) * 2 + 1,
				1
			);

			_vector.unproject( camera );
			
			ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
			intersections = ray.intersectObjects( blocks );

			if ( intersections.length > 0 ) {
				selected_block = intersections[0].object;
				
				_vector.set( 0, 0, 0 );
				selected_block.setAngularFactor( _vector );
				selected_block.setAngularVelocity( _vector );
				selected_block.setLinearFactor( _vector );
				selected_block.setLinearVelocity( _vector );

				mouse_position.copy( intersections[0].point );
				block_offset.subVectors( selected_block.position, mouse_position );
				
				intersect_plane.position.y = mouse_position.y;
			}
		};
		
		handleMouseMove = function( evt ) {
			
			var ray, intersection,
				i, scalar;
			
			if ( selected_block !== null ) {
				
				_vector.set(
					( evt.clientX / window.innerWidth ) * 2 - 1,
					-( evt.clientY / window.innerHeight ) * 2 + 1,
					1
				);
				_vector.unproject( camera );
				
				ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
				intersection = ray.intersectObject( intersect_plane );
				mouse_position.copy( intersection[0].point );
			}
			
		};
		
		handleMouseUp = function( evt ) {
			
			if ( selected_block !== null ) {
				_vector.set( 1, 1, 1 );
				selected_block.setAngularFactor( _vector );
				selected_block.setLinearFactor( _vector );
				
				selected_block = null;
			}
			
		};
		
		return function() {
			renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
			renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
			renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
		};
	})();
	
	window.onload = initScene;
</script>
</head>

<body>
	<div id="heading">
		<h1>FruitSim</h1>
		<p>A Work in Progress...</p>
	</div>
	<div id="viewport"></div>
</body>

</html>
