<!DOCTYPE html>

<html>
<head>
<title>FruitSim</title>

<link rel="stylesheet" type="text/css" href="css/styles.css" />

<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/stats.js"></script>
<script type="text/javascript" src="js/physi.js"></script>

<script type="text/javascript">
    'use strict';

    Physijs.scripts.worker = 'js/physijs_worker.js';
    Physijs.scripts.ammo = 'ammo.js';

    var init, initEngine, initLights, initObjects, initScene, initGUI, initEventHandling;
    
    var render;
    
    var spawnFruit, resetAll;
    var createTower;

    var model_loader, texture_loader;
    
    var container, renderer, render_stats, physics_stats;

    var scene;
    var lights = {};
    var camera;

    var blocks = [];
    var floor, wall1, wall2, wall3;
    var table, melon, bulb, hammer;
    var allFruits = [];
    var fruitCounter = 0;
    var pickable_objects = [];
    
    var table_material, block_material, melon_material, bulb_material, hammer_material;

    var intersect_plane;
    var selected_obj = null;
    var mouse_position = new THREE.Vector3;
    var block_offset = new THREE.Vector3;
    
    var _i;
    var _v3 = new THREE.Vector3;

    initEngine = function() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );

        render_stats = new Stats();
        render_stats.domElement.style.position = 'absolute';
        render_stats.domElement.style.top = '1px';
        render_stats.domElement.style.zIndex = 100;
        document.getElementById( 'viewport' ).appendChild( render_stats.domElement );

        physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );

        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
        scene.addEventListener(
            'update',
            function() {

                if ( selected_obj !== null ) {

                    _v3.copy( mouse_position ).add( block_offset ).sub( selected_obj.position ).multiplyScalar( 5 );
                    _v3.y = 0;
                    selected_obj.setLinearVelocity( _v3 );

                    // Reactivate all of the blocks
                    _v3.set(0, 0, 0);
                    for ( _i = 0; _i < blocks.length; _i++ ) {
                        blocks[_i].applyCentralImpulse( _v3 );
                    }
                }

                scene.simulate( undefined, 1 );
                physics_stats.update();
            }
        );

        camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );
        camera.position.set( 0, 30, 70 );
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        scene.add( camera );
    };

    initLights = function() {
        // ambient light
        lights.am_light = new THREE.AmbientLight( 0x444444 );
        scene.add(lights.am_light);

        // directional light
        lights.dir_light = new THREE.DirectionalLight( 0xFFFFFF );
        lights.dir_light.position.set(20, 35, -5);
        lights.dir_light.target.position.copy(scene.position);
        lights.dir_light.castShadow = true;
        lights.dir_light.shadowCameraLeft = -30;
        lights.dir_light.shadowCameraTop = -30;
        lights.dir_light.shadowCameraRight = 30;
        lights.dir_light.shadowCameraBottom = 30;
        lights.dir_light.shadowCameraNear = 20;
        lights.dir_light.shadowCameraFar = 200;
        lights.dir_light.shadowBias = -.001
        lights.dir_light.shadowMapWidth = lights.dir_light.shadowMapHeight = 2048;
        lights.dir_light.shadowDarkness = .5;
        scene.add(lights.dir_light);
    };

    initObjects = function() {
        // Loaders
        texture_loader = new THREE.TextureLoader();
        model_loader = new THREE.JSONLoader();
        
        // Materials
        table_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/wood.jpg' )}),
            .9, // high friction
            .2 // low restitution
        );
        table_material.map.wrapS = THREE.RepeatWrapping;
        table_material.map.wrapT = THREE.RepeatWrapping;
        table_material.map.repeat.set(5, 5);
        //lightMap for bumpmapping

        block_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/plywood.jpg' )}),
            .4, // medium friction
            .4 // medium restitution
        );
        block_material.map.wrapS = THREE.RepeatWrapping;
        block_material.map.wrapT = THREE.RepeatWrapping;
        block_material.map.repeat.set(1, .5);

        melon_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/melon.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        melon_material.map.wrapS = THREE.RepeatWrapping;
        melon_material.map.wrapT = THREE.RepeatWrapping;
        melon_material.map.repeat.set(5, 5);
        
        bulb_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/bulb.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        bulb_material.map.wrapS = THREE.RepeatWrapping;
        bulb_material.map.wrapT = THREE.RepeatWrapping;
        bulb_material.map.repeat.set(5, 5);
        
        hammer_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({ map: texture_loader.load( 'images/plywood.jpg' )}),
          .4, // medium friction
          .4 // medium restitution
        );
        hammer_material.map.wrapS = THREE.RepeatWrapping;
        hammer_material.map.wrapT = THREE.RepeatWrapping;
        hammer_material.map.repeat.set(5, 5);
    };

    initScene = function() {
        
        var room_piece = new THREE.BoxGeometry(100, 1, 100);
        
        floor = new Physijs.BoxMesh(
            room_piece, 
            table_material,
            0 // mass
        );
        floor.position.set(0,-25,0);
        floor.receiveShadow = true;
        scene.add(floor);
        
        wall1 = new Physijs.BoxMesh(
            room_piece, 
            table_material,
            0 // mass
        );
        wall1.rotation.set((90*Math.PI/180),0,0);
        wall1.position.set(0,0,-25);
        wall1.castShadow = true;
        wall1.receiveShadow = true;
        scene.add(wall1);
        
        wall2 = new Physijs.BoxMesh(
            room_piece, 
            table_material,
            0 // mass
        );
        wall2.rotation.set((90*Math.PI/180),0,(90*Math.PI/180));
        wall2.position.set(50,0,0);
        wall2.castShadow = true;
        wall2.receiveShadow = true;
        scene.add(wall2);
        
        wall3 = new Physijs.BoxMesh(
            room_piece, 
            table_material,
            0 // mass
        );
        wall3.rotation.set((90*Math.PI/180),0,(90*Math.PI/180));
        wall3.position.set(-50,0,0);
        wall3.castShadow = true;
        wall3.receiveShadow = true;
        scene.add(wall3);
        
        model_loader.load("models/table.json",
        function(geometry, materials){
            table = new Physijs.ConvexMesh(
                geometry,
                table_material,
                0, //mass
                {retitution: 0.2, friction: 0.8}
            );
            table.castShadow = true;
            table.receiveShadow = true;
            scene.add(table);
		});
        
        model_loader.load("models/lightbulb.json",
        function(geometry, materials){
            bulb = new Physijs.ConvexMesh(
                geometry,
                bulb_material,
                2, //mass
                {retitution: 0.2, friction: 0.8}
            );
            bulb.position.set(-10,0,0);
            bulb.castShadow = true;
            scene.add(bulb);
            pickable_objects.push(bulb);
		});
        
        model_loader.load("models/hammer.json",
        function(geometry, materials){
            hammer = new Physijs.ConvexMesh(
                geometry,
                hammer_material,
                15, //mass
                {retitution: 0.2, friction: 0.8}
            );
            hammer.position.set(-10,0,10);
            hammer.rotation.set(0,-90,0);
            hammer.castShadow = true;
            hammer.receiveShadow = true;            
            scene.add(hammer);
            pickable_objects.push(hammer);
		});
        
        spawnFruit(); //spawns a fruit object in the center of the table
        createTower(); //creates the jenga tower from the physi.js example

        intersect_plane = new THREE.Mesh(
            new THREE.PlaneGeometry( 150, 150 ),
            new THREE.MeshBasicMaterial({opacity: 0, transparent: true})
        );
        intersect_plane.rotation.x = Math.PI / -2;
        scene.add(intersect_plane);
    };
    

    initGUI = function() {

        gui = new dat.GUI();
        parameters = {
            //reset: function() { resetAll() },
            spawn: function() { spawnFruit() }
        };
  
        //gui.add( parameters, 'reset' ).name("Reset to Default Values");
        gui.add( parameters, 'spawn' ).name("Spawn Fruit");
  
        gui.open();
    };

    
    resetAll = function() {
        for (var i = 0; i < allFruits.length; i++) {
            scene.remove(allFruits[i]);
        }
        fruitCounter = 0;
        spawnFruit;
    }

    
    
    render = function() {
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
    };

    spawnFruit = function() {        
        model_loader.load("models/watermelon.json",
        function(geometry, materials){
            allFruits[fruitCounter] = new Physijs.ConvexMesh(
                geometry,
                melon_material,
                20 //mass
            );
            allFruits[fruitCounter].position.set(15,0,0);
            allFruits[fruitCounter].castShadow = true;
            allFruits[fruitCounter].receiveShadow = true;
            scene.add(allFruits[fruitCounter]);
            pickable_objects.push(allFruits[fruitCounter]);
            fruitCounter += 1;
		});
    };

    createTower = function() {
        var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
            block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
        return function() {
            var i, j, rows = 16,
                block;
            for ( i = 0; i < rows; i++ ) {
                for ( j = 0; j < 3; j++ ) {
                    block = new Physijs.BoxMesh( block_geometry, block_material );
                    block.position.y = (block_height / 2) + block_height * i;
                    if ( i % 2 === 0 ) {
                        block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
                        block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    } else {
                        block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    }
                    block.receiveShadow = true;
                    block.castShadow = true;
                    scene.add(block);
                    pickable_objects.push(block);
                    blocks.push(block);
                }
            }
        }
    }();
    
    initEventHandling = function() {
        var _vector = new THREE.Vector3,
            handleMouseDown, handleMouseMove, handleMouseUp;

/*      handleMouseDown = function(evt) {
            var ray, intersections;
			_vector.set(
                (evt.clientX / window.innerWidth) * 2 - 1,
                -(evt.clientY / window.innerHeight) * 2 + 1,
                1
            );
            _vector.unproject(camera);
            ray = new THREE.Raycaster(camera.position, _vector.sub(camera.position).normalize());
            intersections = ray.intersectObjects(blocks);

            if (intersections.length > 0) {
                console.log(intersections);
                selected_obj = intersections[0].object;

                _vector.set(0, 0, 0);
                selected_obj.setAngularFactor(_vector);
                selected_obj.setAngularVelocity(_vector);
                selected_obj.setLinearFactor(_vector);
                selected_obj.setLinearVelocity(_vector);

                mouse_position.copy( intersections[0].point );
                block_offset.subVectors( selected_obj.position, mouse_position );

                intersect_plane.position.y = mouse_position.y;
            }
        };*/
        
        handleMouseDown = function(evt) {
			//ray.setFromCamera(mouse, camera);
            var ray, intersections;
            _vector.set(
                (evt.clientX / window.innerWidth) * 2 - 1,
                -(evt.clientY / window.innerHeight) * 2 + 1,
                1
            );
            _vector.unproject(camera);
            ray = new THREE.Raycaster(camera.position, _vector.sub(camera.position).normalize());
				intersections = ray.intersectObjects(pickable_objects);
				if (intersections.length > 0) {
					//controls.enabled = false;
					selected_obj = intersections[ 0 ].object;
					//var intersections = ray.intersectObject( plane );
					if (intersections.length > 0) {
						mouse_position.copy( intersections[0].point );
                        block_offset.subVectors( selected_obj.position, mouse_position );
                        intersect_plane.position.y = mouse_position.y;
					}
					//container.style.cursor = 'move';
				}
        }
        
        handleMouseMove = function(evt) {
            var ray, intersection,
                i, scalar;

            if (selected_obj !== null) {
                _vector.set(
                    (evt.clientX / window.innerWidth) * 2 - 1,
                    -(evt.clientY / window.innerHeight) * 2 + 1,
                    1
                );
                _vector.unproject(camera);
                ray = new THREE.Raycaster(camera.position, _vector.sub(camera.position).normalize());
                intersection = ray.intersectObject(intersect_plane);
                mouse_position.copy(intersection[0].point);
            }
        };

        handleMouseUp = function( evt ) {
            if (selected_obj !== null) {
                _vector.set(1, 1, 1);
                selected_obj.setAngularFactor( _vector );
                selected_obj.setLinearFactor( _vector );
				selected_obj = null;
            }
        };
        return function() {
            renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
            renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
            renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
        };
    }();
    
    init = function() {
        initEngine();
        initLights();
        initObjects();
        initScene();
        initEventHandling();
        requestAnimationFrame(render);
        scene.simulate();
    };
    

window.onload = init;
</script>
</head>

<body>
    <div id="heading">
        <h1>FruitSim</h1>
        <p>A Work in Progress...</p>
    </div>
    <div id="viewport"></div>
</body>

</html>
